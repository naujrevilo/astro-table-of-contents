---
import type { MarkdownHeading } from 'astro'
import { z } from 'zod'

// Esquema de validación para las props
const PropsSchema = z.object({
  headings: z.array(
    z.object({
      depth: z.number().min(1).max(6),
      slug: z.string(),
      text: z.string()
    })
  ).min(1),
  title: z.string().default('Tabla de Contenido'),
  showProgress: z.boolean().default(true),
  sticky: z.boolean().default(true)
}).strict()

type Props = z.infer<typeof PropsSchema>

// Validar props
let validatedProps: Props
try {
  validatedProps = PropsSchema.parse(Astro.props)
} catch (error) {
  console.error('Error validando props:', error)
  validatedProps = {
    headings: [],
    title: 'Tabla de Contenido',
    showProgress: true,
    sticky: true
  }
}

const { headings, title, showProgress, sticky } = validatedProps

// Procesar headings
let processedHeadings = []

// Si no se proporcionan headings, detectarlos automáticamente del documento
if (!headings || headings.length === 0) {
  const docHeadings = Array.from(document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]'))
    .map(heading => ({
      depth: parseInt(heading.tagName.substring(1)),
      slug: heading.id,
      text: heading.textContent || ''
    }));
  
  processedHeadings = docHeadings
    .filter(({ depth }) => depth >= 1 && depth <= 6)
    .map((heading, index) => ({
      ...heading,
      number: `${index + 1}.`,
      isSubheading: heading.depth >= 3
    }));
} else {
  processedHeadings = headings
    .filter(({ depth }) => depth >= 1 && depth <= 6)
    .map((heading, index) => ({
      ...heading,
      number: `${index + 1}.`,
      isSubheading: heading.depth >= 3
    }));
}
---

<div class={`bg-surface-50 dark:bg-surface-800 p-6 rounded-lg border border-surface-200 dark:border-surface-700 ${sticky ? 'sticky top-8' : ''}`}>
  <h2
    id='table-of-contents-title'
    class='text-lg font-semibold mb-4 text-surface-900 dark:text-surface-100 flex items-center gap-2'
  >
    <span>📑</span>
    <span>{title}</span>
  </h2>
  
  {showProgress && (
    <div class='mb-4 text-xs text-surface-600 dark:text-surface-400'>
      <div class='flex items-center gap-2'>
        <span>Progreso:</span>
        <span class='reading-progress font-mono text-primary-600 dark:text-tertiary-400'>0</span>
        <div class='flex-1 h-1 bg-surface-200 dark:bg-surface-700 rounded-full overflow-hidden'>
          <div class='progress-bar h-full bg-tertiary-500 transition-all duration-300 ease-out' style='width: 0%'></div>
        </div>
      </div>
    </div>
  )}
  
  <nav class='toc-nav'>
    <ol role='list' class='space-y-1 text-sm'>
      {
        processedHeadings.map((heading) => (
          <li>
            <a 
              href={`#${heading.slug}`}
              data-heading-id={heading.slug}
              class={`
                toc-link block py-2 px-3 rounded-md transition-all duration-200 
                ${heading.isSubheading 
                  ? 'ml-6 text-xs text-surface-600 dark:text-surface-400 border-l-2 border-surface-200 dark:border-surface-700 pl-3' 
                  : 'text-surface-700 dark:text-surface-200 font-medium'
                }
                hover:bg-primary-50 dark:hover:bg-primary-900/20 
                hover:text-tertiary-700 dark:hover:text-tertiary-300
                hover:no-underline
              `}
            >
              <span class='toc-number text-surface-400 dark:text-tertiary-500 mr-2 font-mono text-xs'>
                {heading.number}
              </span>
              <span class='toc-text'>{heading.text}</span>
            </a>
          </li>
        ))
      }
    </ol>
  </nav>
</div>

<script is:inline>
  // Función para inicializar TOC una sola vez 
  function initTOC() {
    // Evitar múltiples inicializaciones
    if (window.__tocInitialized) return;
    window.__tocInitialized = true;

    console.log('TOC: Inicializando...');

    // Configuración del observador de intersección
    const observerOptions = {
      root: null,
      rootMargin: '-20% 0px -50% 0px',
      threshold: 0.1
    };

    // Elementos del DOM
    const progressElements = document.querySelectorAll('.reading-progress');
    const progressBars = document.querySelectorAll('.progress-bar');
    const tocLinks = document.querySelectorAll('.toc-link');
    const headings = document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]');

    console.log('TOC: Elementos encontrados:', {
      progressElements: progressElements.length,
      progressBars: progressBars.length,
      tocLinks: tocLinks.length,
      headings: headings.length
    });

    if (!progressElements.length || !progressBars.length || !tocLinks.length) {
      console.error('TOC: Error - Elementos requeridos no encontrados:', {
        progressElements: progressElements.length,
        progressBars: progressBars.length,
        tocLinks: tocLinks.length,
      });
      window.__tocInitialized = false;
      return;
    }
    
    // Si no hay headings, intentar detectarlos automáticamente
    if (!headings.length) {
      headings = Array.from(document.querySelectorAll('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]'));
      console.log('TOC: Headings detectados automáticamente:', headings.length);
    }

    // Estado actual
    let currentActiveId = '';
    
    // Función para actualizar el progreso de lectura
    function updateReadingProgress() {
      const windowHeight = window.innerHeight;
      const documentHeight = document.documentElement.scrollHeight - windowHeight;
      const scrolled = window.scrollY;
      const progress = Math.min(Math.max(scrolled / documentHeight, 0), 1);
      const progressPercentage = Math.round(progress * 100);
      
      console.log('TOC: Progreso actualizado:', { scrolled, documentHeight, progress, progressPercentage });
      
      // Actualizar todos los elementos de progreso
      progressElements.forEach(element => {
        element.textContent = progressPercentage;
      });
      
      progressBars.forEach(bar => {
        bar.style.width = progressPercentage + '%';
      });
    }

    // Función para activar/desactivar enlaces del TOC
    function setActiveLink(activeId) {
      if (currentActiveId === activeId) return;
      
      console.log('TOC: Activando enlace:', activeId);
      
      // Remover clase activa de todos los enlaces
      tocLinks.forEach(link => {
        link.classList.remove('active');
        link.classList.remove('bg-primary-100', 'dark:bg-primary-900/40', 'text-primary-800', 'dark:text-tertiary-200');
        link.classList.add('hover:bg-tertiary-50', 'dark:hover:bg-tertiary-900/20');
      });
      
      // Activar el enlace correspondiente
      if (activeId) {
        const activeLinks = document.querySelectorAll('[data-heading-id="' + activeId + '"]');
        activeLinks.forEach(activeLink => {
          activeLink.classList.add('active');
          activeLink.classList.add('bg-primary-100', 'dark:bg-primary-900/40', 'text-tertiary-800', 'dark:text-tertiary-200');
          activeLink.classList.remove('hover:bg-primary-50', 'dark:hover:bg-primary-900/20');
          
          // Auto-scroll del TOC para mantener el enlace activo visible
          scrollActiveLinkIntoView(activeLink);
        });
      }
      
      currentActiveId = activeId;
    }

    // Función para hacer scroll automático en el TOC
    function scrollActiveLinkIntoView(activeLink) {
      // Encontrar el contenedor del TOC (nav.toc-nav)
      const tocNav = activeLink.closest('.toc-nav');
      if (!tocNav) return;
      
      // Calcular posiciones
      const tocNavRect = tocNav.getBoundingClientRect();
      const activeLinkRect = activeLink.getBoundingClientRect();
      
      // Verificar si el enlace activo está fuera del área visible del TOC
      const isAboveVisible = activeLinkRect.top < tocNavRect.top;
      const isBelowVisible = activeLinkRect.bottom > tocNavRect.bottom;
      
      if (isAboveVisible || isBelowVisible) {
        // Calcular la posición de scroll necesaria
        const tocNavScrollTop = tocNav.scrollTop;
        const activeLinkOffsetTop = activeLink.offsetTop;
        const tocNavHeight = tocNav.clientHeight;
        const activeLinkHeight = activeLink.offsetHeight;
        
        // Centrar el enlace activo en el TOC
        const targetScrollTop = activeLinkOffsetTop - (tocNavHeight / 2) + (activeLinkHeight / 2);
        
        // Hacer scroll suave
        tocNav.scrollTo({
          top: Math.max(0, targetScrollTop),
          behavior: 'smooth'
        });
      }
    }

    // Observador de intersección para detectar qué sección está visible
    const observer = new IntersectionObserver(function(entries) {
      let visibleHeading = null;
      
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          visibleHeading = entry.target;
        }
      });
      
      if (visibleHeading && visibleHeading.id) {
        setActiveLink(visibleHeading.id);
      }
    }, observerOptions);

    // Observar todos los headings válidos (con ID)
    headings.forEach(function(heading) {
      if (heading && heading.id) {
        observer.observe(heading);
      } else {
        console.warn('TOC: Heading sin ID ignorado:', heading);
      }
    });

    // Smooth scroll para los enlaces del TOC
    tocLinks.forEach(function(link) {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        const href = link.getAttribute('href');
        if (!href) return;
        
        const targetId = href.substring(1);
        const targetElement = document.getElementById(targetId);
        
        if (targetElement) {
          targetElement.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
          });
          
          // Actualizar URL sin salto
          history.pushState({}, '', '#' + targetId);
        }
      });
    });

    // Event listeners
    window.addEventListener('scroll', updateReadingProgress, { passive: true });
    window.addEventListener('resize', updateReadingProgress, { passive: true });
    
    // Inicializar progreso inmediatamente
    setTimeout(updateReadingProgress, 100);
    
    // Si hay un hash en la URL, activar ese enlace
    if (window.location.hash) {
      const hashId = window.location.hash.substring(1);
      setActiveLink(hashId);
    }

    console.log('TOC: Inicializado correctamente');
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTOC);
  } else {
    initTOC();
  }
</script>

<style>
  .toc-nav ol {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  
  .toc-link:hover {
    text-decoration: none;
  }
  
  .toc-link.active {
    transform: translateX(2px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .dark .toc-link.active {
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  }
  
  /* Animación suave para los números */
  .toc-number {
    transition: all 0.2s ease;
  }
  
  .toc-link.active .toc-number {
    color: theme('colors.tertiary.600');
    font-weight: 600;
  }
  
  .dark .toc-link.active .toc-number {
    color: theme('colors.tertiary.400');
  }
  
  /* Scrollbar personalizado para el TOC */
  .toc-nav {
    max-height: 60vh;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: thin;
    scrollbar-color: theme('colors.secondary.300') theme('colors.surface.100');
    scroll-behavior: smooth;
  }
  
  .toc-nav::-webkit-scrollbar {
    width: 6px;
  }
  
  .toc-nav::-webkit-scrollbar-track {
    background: theme('colors.surface.100');
    border-radius: 3px;
  }
  
  .toc-nav::-webkit-scrollbar-thumb {
    background-color: theme('colors.tertiary.300');
    border-radius: 3px;
    transition: background-color 0.2s ease;
  }
  
  .toc-nav::-webkit-scrollbar-thumb:hover {
    background-color: theme('colors.tertiary.400');
  }
  
  .dark .toc-nav {
    scrollbar-color: theme('colors.primary.600') theme('colors.surface.700');
  }
  
  .dark .toc-nav::-webkit-scrollbar-track {
    background: theme('colors.surface.700');
  }
  
  .dark .toc-nav::-webkit-scrollbar-thumb {
    background-color: theme('colors.primary.600');
  }
  
  .dark .toc-nav::-webkit-scrollbar-thumb:hover {
    background-color: theme('colors.primary.500');
  }
</style>
